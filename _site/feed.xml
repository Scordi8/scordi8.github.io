<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2026-01-31T07:53:48+10:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Scordi</title><subtitle>I&apos;m a indie game developer with years of experience with Godot and Blender.</subtitle><entry><title type="html">CBR and Procedural Generation</title><link href="http://localhost:4000/gamedev/2026/01/31/cbr-and-procedural-generation.html" rel="alternate" type="text/html" title="CBR and Procedural Generation" /><published>2026-01-31T07:03:00+10:00</published><updated>2026-01-31T07:03:00+10:00</updated><id>http://localhost:4000/gamedev/2026/01/31/cbr-and-procedural-generation</id><content type="html" xml:base="http://localhost:4000/gamedev/2026/01/31/cbr-and-procedural-generation.html"><![CDATA[<p>Procedural generation is one of those things that just keeps popping up in gamedev no matter where you look. I don’t think that will change, and someday, someone will want to know how SCP - Containment Breach Reborn’s (CBR) procgen worked.</p>

<p>Now, Hyperity has played with a few versions of procedural generation. For a currently shelved Hyperity project, known only by its internal name of CW, a basic system that distributed rooms and connected them up was designed. It was written in Python and used cv2 to draw an image where white pixels were hallways, and black pixels were free space. It worked pretty decently, but never reached the Godot implementation stage, as CW was shelved.</p>

<p>Placing a bunch of squares on a grid is easy when the squares are all the same size, but CBR rooms aren’t all the same size, or even the same shape. There’s not even a set number of rooms in CBR. The next iteration of the CW procgen saw squares with different sizes being distributed across the image, although the positioning was still completely random. A simple check for existing rooms and a limit to the amount of tries the algorithm could try to place a room was all it needed.</p>

<p>The next step was to pack all the shapes into a smaller space. There’s a term for this stuff, called a Packing Algorithm, which are solutions to Packing Problems. The specific type we use (to my limited knowledge) would be called an online bin packing algorithm. Why ‘online’? Because an online algorithm doesn’t know the entire set of rooms, whereas an offline algorithm would know the entire set. By using an online algorithm, the order in which we provide the rooms to be placed changes the outcome of the distribution. The order is shuffled depending on the random number generator’s seed, creating a deterministic procedural generation algorithm.</p>

<p>However, there’s a little more to it than just that, so I’ll walk you through the pseudocode.</p>

<ul>
  <li>Algorithm start, provided a list of rooms</li>
  <li>Create a small grid around the size of the first room in the list.</li>
  <li>For each room:
    <ul>
      <li>Find the best fitting position of the room on the grid by searching over every grid cell</li>
      <li>If there’s not enough space, make the grid bigger and try again</li>
      <li>When space has been found, keep track of the room’s size, and where it was placed</li>
      <li>All rooms should check if a room of similar or smaller size has been placed. If it has, find where it stopped searching for space for that size of room, and start searching from there.</li>
      <li>Make sure there’s at least a single grid cell space between all other place rooms</li>
    </ul>
  </li>
  <li>Algorithm end.
That, when given a list of room shapes, will produce a relatively well-packed distribution of rooms with enough space to add hallways in.</li>
</ul>

<p>And speaking of hallways, the hallways happen in three stages.</p>
<ol>
  <li>Create a weightmap The weightmap is a 2d grid where each cell has an integer value of steps from the origin, with the origin starting as the player’s spawn room. This is an initialisation stage, and I don’t count it as part of the hallway algorithm.</li>
  <li>From each doorway (user-defined room entrance):
    <ul>
      <li>Backtrack along the lowest stepped cells to reach the origin, and mark each step as a hallway cell.</li>
      <li>Regenerate the weightmap with each new hallway cell counting as the origin. This makes new hallways connect with existing hallways.</li>
    </ul>
  </li>
  <li>Perform an ‘orientation pass’ on the hallway cells, converting them from ‘alive or dead’ into hallway type (e.g. straight hallway, X intersection hallway, North-west corner hallway)</li>
  <li>Each hallway is given a random number within a small range (0 to 5 at the time of writing). If two connected hallways have the same random number, a divider wall will not spawn between them.</li>
</ol>

<p>And that’s it. It’s a fairly simple system in theory, and although the implementation tastes like spaghetti, it works like a charm and is easy to add new rooms to. Even better, each step of the overall generation system is its own system built off Godot’s Tilemaps, so modders could potentially swap out the generation algorithms for their own code.</p>]]></content><author><name></name></author><category term="gamedev" /><summary type="html"><![CDATA[Procedural generation is one of those things that just keeps popping up in gamedev no matter where you look. I don’t think that will change, and someday, someone will want to know how SCP - Containment Breach Reborn’s (CBR) procgen worked.]]></summary></entry><entry><title type="html">Creating Traversion</title><link href="http://localhost:4000/gamedev/2026/01/31/creating-traversion.html" rel="alternate" type="text/html" title="Creating Traversion" /><published>2026-01-31T07:03:00+10:00</published><updated>2026-01-31T07:03:00+10:00</updated><id>http://localhost:4000/gamedev/2026/01/31/creating-traversion</id><content type="html" xml:base="http://localhost:4000/gamedev/2026/01/31/creating-traversion.html"><![CDATA[<p>During the final year of university, the capstone for the Game Design degree was to create a video game. In a group of four, my team started with ambition. We agreed to create a first-person-shooter located in rural Australia, using Unreal Engine. And if you’re thinking ‘Gee Scordi, that sounds nothing like the Traversion I know!’, well, you’d be right…</p>

<p>About halfway through the year, at the start of the second semester, the team and the lecturer had a chat. Basically, we concluded that we weren’t confident in completing what we thought we could, and scrapped the idea completely. We were back to the drawing board, but I pitched the idea of a movement platformer, and over a few weeks, we planned out what Traversion is today. However, we didn’t start actually developing the game until about the fourth week of the second semester. At this stage, pretty much every other group was well underway with their own projects, while we were back to square one.</p>

<p>However, after doing the gamedev equivalent of snorting crack, we got to work. By the end of the third week, we had a basic framework. It wasn’t great, it wasn’t complex, but it worked. It covered player movement, rockets and blast jumping, checkpoints and killboxes. The fundamentals that we built the prototype levels around.</p>

<p>But the first few days also added a single script that I still use today. The ConfigHandler script, a back end system for reading and writing player configurations. Keybinds, graphics settings, mouse and audio options. Of course, ConfigHandler would later undergo revision after revision, but we’ll get to that another time.</p>

<p>Traversion, at just a few days old, looked pretty terrible. Not really a surprise, since all we had were a few cubes to test stuff with, but it led to another issue. Our team didn’t have anybody who specialised in asset creation. The low poly style we ‘chose’ was really the only option we had at the time, and without texture artists, we went with flat vertex colouring over texturing. The end result wasn’t pretty, but it was functional, and for a bunch of programmers, that was good enough for us.</p>

<p>Over about six weeks, we developed around twenty playable levels, added features like the grappling hook and the slowfall ability, and got the university tutor to playtest. If you’ve seen any of the old Traversion media, which you likely have, as at the time of writing this we haven’t replaced them with new ones yet. Old Traversion was bland. Flat and undetailed surfaces messed with depth perception, and the player movement was generic.</p>

<p>Still, we launched on steam for $3 AUD as the semester concluded. We got a few sales, more than we expected, less than we hoped. In hindsight, it’s surprising we got any with our quality of promotional media.</p>

<p>After university finished, the team stopped focusing on the project as we all drifted off into our own lives, although occasionally there’d be a contribution. Two years later, around the middle of 2025, I bought ownership of the project from the rest of the team, and continued to work on it in my own time.</p>

<p>Since graduation, I overhauled the menus, the movement systems, the visual style, and the existing levels. Playtesting run by Minirow, the Hyperity co-director, helped to refine the gameplay and feel, creating a much more enjoyable experience.</p>]]></content><author><name></name></author><category term="gamedev" /><summary type="html"><![CDATA[During the final year of university, the capstone for the Game Design degree was to create a video game. In a group of four, my team started with ambition. We agreed to create a first-person-shooter located in rural Australia, using Unreal Engine. And if you’re thinking ‘Gee Scordi, that sounds nothing like the Traversion I know!’, well, you’d be right…]]></summary></entry></feed>